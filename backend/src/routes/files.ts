import { Router } from 'express';
import multer from 'multer';
import path from 'path';
import fs from 'fs';
import { db } from '../services/database';
import { AuthenticatedRequest } from '../types';
import { logger } from '../utils/logger';

const router = Router({ mergeParams: true }); // To get :workspaceId if nested

const UPLOAD_DIR = path.join(__dirname, '../../uploads'); // Adjusted path relative to src/routes
if (!fs.existsSync(UPLOAD_DIR)) {
  fs.mkdirSync(UPLOAD_DIR, { recursive: true });
}

const MAX_FILE_SIZE_MB = 100;
const MAX_FILE_SIZE_BYTES = MAX_FILE_SIZE_MB * 1024 * 1024;

// Multer storage configuration
const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, UPLOAD_DIR);
  },
  filename: function (req: AuthenticatedRequest, file, cb) {
    const userId = req.user?.id || 'unknown_user';
    const uniqueSuffix = Date.now() + '_' + userId;
    // Sanitize originalname: remove special characters, limit length if necessary
    const safeOriginalName = file.originalname.replace(/[^a-zA-Z0-9._-]/g, '_');
    cb(null, uniqueSuffix + '_' + safeOriginalName);
  }
});

// Multer file filter (example: allow common image types and PDFs, check size)
const fileFilter = (req: AuthenticatedRequest, file: Express.Multer.File, cb: multer.FileFilterCallback) => {
  const allowedMimeTypes = [
    'image/jpeg', 'image/png', 'image/gif', 'image/webp',
    'application/pdf',
    'text/plain',
    // Add more as needed based on REQ-021 (common document formats)
    'application/msword',
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
    'application/vnd.ms-excel',
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
    'application/vnd.ms-powerpoint',
    'application/vnd.openxmlformats-officedocument.presentationml.presentation'
  ];

  if (allowedMimeTypes.includes(file.mimetype)) {
    cb(null, true);
  } else {
    cb(new Error('Invalid file type. Only images, PDFs, and common documents are allowed.'));
  }
};

const upload = multer({
  storage: storage,
  fileFilter: fileFilter,
  limits: { fileSize: MAX_FILE_SIZE_BYTES }
});


// POST /api/workspaces/:workspaceId/files/upload
router.post('/upload', upload.single('file'), async (req: AuthenticatedRequest, res) => {
  try {
    const { workspaceId } = req.params; // If route is /api/workspaces/:workspaceId/files/upload
    const uploaderId = req.user!.id;

    if (!req.file) {
      return res.status(400).json({ error: 'No file uploaded.' });
    }

    // Verify user is part of the workspace (if workspaceId is used)
    if (workspaceId) {
        const membership = await db.member.findUnique({
            where: { userId_workspaceId: { userId: uploaderId, workspaceId } }
        });
        if (!membership) {
            // If file was saved by multer, attempt to delete it
            fs.unlink(req.file.path, (err) => {
                if (err) logger.error(`Failed to delete orphaned file: ${req.file?.path}`, err);
            });
            return res.status(403).json({ error: 'User is not a member of this workspace.' });
        }
    }


    const attachment = await db.attachment.create({
      data: {
        filename: req.file.originalname, // Original filename for display
        mimetype: req.file.mimetype,
        size: req.file.size,
        url: req.file.filename, // The unique filename generated by multer
        uploaderId,
        workspaceId: workspaceId || null, // Handle if workspaceId is optional or not part of route
      },
      include: {
        uploader: { select: { id: true, username: true, name: true } }
      }
    });

    logger.info(`File uploaded: ${attachment.filename} by user ${uploaderId} to workspace ${workspaceId || 'none'}`);
    res.status(201).json({ attachment });

  } catch (error: any) {
    logger.error('File upload error:', error);
    // If multer throws an error (e.g., file too large), it might have a specific structure
    if (error instanceof multer.MulterError) {
        if (error.code === 'LIMIT_FILE_SIZE') {
            return res.status(413).json({ error: `File too large. Max size is ${MAX_FILE_SIZE_MB}MB.` });
        }
        return res.status(400).json({ error: `Multer error: ${error.message}` });
    }
    if (error.message.startsWith('Invalid file type')) {
        return res.status(415).json({ error: error.message });
    }
    res.status(500).json({ error: 'Failed to upload file.' });
  }
});

// GET /api/workspaces/:workspaceId/files/view/:fileIdentifier
// (or /api/files/view/:fileIdentifier if workspaceId not needed for auth here, but it's good for scoping)
// For simplicity, let's make a general /api/files/view/:fileIdentifier and auth within.
// The frontend currently constructs `/api/files/view/${attachment.url}`
// So, the route should be /api/files/view/:uniqueFilename
// Let's adjust the router base path in server.ts later if needed, or add a new top-level router for /api/files.
// For now, let's assume this router is mounted at /api/files and the :workspaceId part is not used for this GET.

router.get('/view/:uniqueFilename', async (req: AuthenticatedRequest, res) => {
  try {
    const { uniqueFilename } = req.params;
    const userId = req.user!.id;
    const download = req.query.download === 'true';

    // Fetch attachment details from DB to get mimetype, original filename, and verify access
    const attachment = await db.attachment.findFirst({ // Assuming url stores the uniqueFilename
      where: { url: uniqueFilename },
      include: {
        message: { // To check if user has access via message context
          include: {
            channel: { include: { members: { where: { userId } } } },
            // For DMs:
            // user: true, // sender
            // recipient: true
          }
        },
        workspace: { include: { members: { where: { userId } } } } // To check if user has access via workspace
      }
    });

    if (!attachment) {
      return res.status(404).json({ error: 'File not found or attachment record missing.' });
    }

    // Authorization logic:
    // User must be uploader OR part of the workspace OR part of the channel/DM the message (if any) is in.
    let authorized = false;
    if (attachment.uploaderId === userId) {
      authorized = true;
    } else if (attachment.workspaceId && attachment.workspace?.members.length > 0) {
      authorized = true; // User is member of the workspace attachment is scoped to
    } else if (attachment.message) {
      if (attachment.message.channelId && attachment.message.channel?.members.length > 0) {
        authorized = true; // User is member of the channel the message is in
      } else if (attachment.message.recipientId) { // DM
        if (attachment.message.userId === userId || attachment.message.recipientId === userId) {
          authorized = true; // User is part of the DM
        }
      }
    }

    if (!authorized) {
      return res.status(403).json({ error: 'You are not authorized to access this file.' });
    }

    const filePath = path.join(UPLOAD_DIR, attachment.url); // attachment.url is the unique filename

    if (fs.existsSync(filePath)) {
      res.setHeader('Content-Type', attachment.mimetype);
      if (download) {
        res.setHeader('Content-Disposition', `attachment; filename="${attachment.filename}"`);
      }
      // For better performance with large files, use streams:
      const fileStream = fs.createReadStream(filePath);
      fileStream.pipe(res);
      // res.sendFile(filePath); // Simpler for smaller files, but less performant
    } else {
      logger.error(`File not found on disk: ${filePath} for attachment ID: ${attachment.id}`);
      return res.status(404).json({ error: 'File not found on server.' });
    }

  } catch (error) {
    logger.error('File serving error:', error);
    res.status(500).json({ error: 'Failed to serve file.' });
  }
});


export default router;
